                                                        NOTES
                                                        -----
Indecision App
--------------

Setting up a Web Server
    - live-server with npm

Hello React
    - Going to define a template, and then render it in the <body> of our index.html page
    - For now, use React by the CDN (<script>)
    - React can be used in many different contexts, such as react-vr for VR development, react-native, etc.
        - Each package gets installed separately
        - We're using react-dom -> Let's us render our React template to the browser
    - If you run live-server and check DevTools console, we now have access to the React and ReactDOM objects
    - JSX = Javascript XML
        - Javascript syntax extension - not part of the core language. It is provided by React
            - Other example of extending languages you might be familiar with -> CSS (SCSS, LESS)
        - In app.js -> var template = <p>This is JSX from app.js!</p>
            - Looks weird, but this is your first JSX static template, congrats!

        - var appRoot = document.getElementById('app');
          ReactDOM.render(template, appRoot);

            - ReactDOM.render(<template you want to render>, <element you want to render the template on>)
                - Used to render our template, as you can see
        - If you try to now run index.html in the browser, you get an "Unexpected token <" error - what gives??
            - Remember, JSX is NOT part of Javascript's core; It is an extension. That means that the browser doesn't understand html tags in your *js file!
        - To solve this, we need to convert our JSX code to JS code. We do this with Babel
            - We'll compile our JSX to JS, as well as compile it to ES5 code. We'll still be able to code in JSX, and let Babel do the work
            - So -> var template = <p>This is JSX from app.js!</p> now translates to -> var template = React.createElement("p", null, "This is JSX from app.js!");
                - React.createElement(<tag>, <attributes (object form)>, <content in tag>);
                    - Ex: React.createElement("h1", { id: "someId" }, "Something new"); -> <h1 id="someId">Something new</h1>
                - This is something the browser understands

Setting Up Babel
    - babel-cli@6.24.1
    - yarn init -> exactly like npm init
    - yarn.lock -> exactly like package-lock
    - Made a src/app.js file
        - This is where we will write our JSX code
        - Then, the babel compiled code will go into scripts/app.js, which index.html will look at in order to render everything on the page
    - babel src/app.js --out-file=public/scripts/app.js --presets=env,react
        - babel <file we want to compile> <file we want to dump our compiled code to> <any presets we want to use for the compilation process>
        - Calling the command changed the code in scripts/app.js!
        - You can add --watch to the previous command to automatically have changed compiled into scripts/app.js

Exploring JSX
    - Let's add more info besides our <h1> tag -> var template = <h1>Indecision App</h1><p>This is some info</p>;
    - If we try to compile the code we now get an error -> "JSX expressions must have one parent element"
        - Just like Vue with templates, with JSX, you can only have ONE root element, not two!
        - Solution: Surround everything in a <div> -> var template = <div><h1>Indecision App</h1><p>This is some info</p></div>;
            - You can put the code on new lines, save the file, and see that nothing changes in the browser. Babel understands that formatting:
                - var template =
                    <div>
                        <h1>Indecision App</h1>
                        <p>This is some info</p>
                    </div>;
            - The formatting can look a little wonky though. Total preference, but you can add parentheses in the beginning and end if you want:
                - var template = (
                    <div>
                        <h1>Indecision App</h1>
                        <p>This is some info</p>
                    </div>
                  )

JSX Expressions
    - <h1>Michael Ababio</h1>
        - Right now, this is statically defined. The only way to change this name is to go in the JSX file and manually change it
        - We want to replace it with a variable, so we can dynamically change the name
            - Just like Vue, etc.

    - var userName = 'Andrew';
      <h1>{userName}</h1>

        - Notice how we only use ONE set of curly braces
        - You can put any Javascript expression in there (again, like Vue, etc.)
        - Ex: var userName = 'Michael';
              var userAge = 26;
              var userLocation = 'Madison';
              var templateTwo = (
                  <div>
                      <h1>{userName}</h1>
                      <p>Age: {userAge}</p>
                      <p>Location: {userLocation}</p>
                  </div>
              ); 

        - What about objects??
            - var user = {
                name: 'Michael',
                age: 26,
                location: 'Madison'
              }
              <h1>{user}</h1> // Throws an error!

            - We get an error in the console that 'Objects are not valid as a React child'
            - Basically, React doesn't know how you want to render an object itself
                - You can still use an object's keys though -> <h1>{user.name}</h1> // This works!

Conditional Rendering in JSX
    - If statements, ternary, logical AND, OR, etc. are still the same
    - One neat thing to note: Remember that you use one set of curly braces to do a Javascript expression? You can also include tags in them!
        - Ex: {<h3>My h3</h3>}
            - This is helpful because you can create a function that could return the whole template tag in it if you wanted to
        - Note: If a Javascript expression returns undefined, the JSX does NOT return/show anything at all
            - It's as if you called 'display: none' on an element-it's just gone, and not on the DOM
            - undefined, null, and boolean values are IGNORED in JSX {true/false}, {null}, {undefined} // All of these will render nothing on the screen
    - Logical AND
        - Remember it's different in Javascript!

            - Ex: true && 'Some age' -> Returns 'Some Age'
                  false && 'Some age -> returns false

                - And since JSX doesn't render false values, if it's false it wont render anything

ES6 Aside: const and let
    - As expected, block level scoping; Try to avoid var

ES6 Aside: Arrow Functions (Parts I and II)
    - All arrow functions are anonymous; You can't 'name' an arrow function. The only way to reference it is to store it in a variable
        - Ex: const square = (x) => { return x * x; };
    - Arguments object is longer bound with arrow functions
        - // ES5
          const add = function(a, b) {
              console.log(arguments);
              return a + b;
          };
          console.log(add(55, 1));

          - With ES5, you could explicitly state your parameters like normal and be fine, but you also have access to the special 'arguments' object
          - I could change console.log to be -> console.log(add(55, 1, 1001));, and if i inspected the arguments object, it would have [55, 1, 1001, callee: {...}, etc.]
            - So basically it will show even anonymous amount of arguments
        - We no longer get access to this object with arrow functions
            - const add = (a, b) => {
                console.log(arguments);     // Error! 'arguments' is not defined!
                return a + b;
            };
            console.log(add(55, 1, 1001));

    - The 'this' keyword is no longer bound to arrow functions either!
        - // ES5
          const user = {
              name: 'Michael',
              cities: ['Madison', 'Platteville', 'Rothbury'],
              printPlacesLived: function() {
                  console.log(this.name);
                  console.log(this.cities);
              }
          };

          user.printPlacesLived();

            - If you look at the console, you'll notice that this.name and this.cities both prints out the correct values
            - That means that within the object, if this is in a value of a property, or a function value of a property, this can still access all of the object's values

            - What happens if we change it to this??
                - printPlacesLived: function() {
                  console.log(this.name);
                  console.log(this.cities);
  
                  this.cities.forEach(function(city) {
                      console.log(this.name + ' has lived in ' + city); // Ruh Roh!
                  });
                  ...
                  user.printPlacesLived();
              }

                - We get an ERROR! - It says this.name is not defined in our forEach loop!
                - 'this' is not bound to anything in our anonymous function, so it is set to undefined

            - Now, there have been workarounds for this already used in the past, such as
                - creating a 'that' variable
                    - printPlacesLived: function() {
                      const that = this;
                      this.cities.forEach(function(city) {
                          console.log(that.name + ' has lived in ' + city);
                      });
                  }
                  ...
                  user.printPlacesLived();

                    - Using 'that' allows you to have access to your object properties, even in nested functions

        - With ES6, arrow functions no longer bind their own 'this' value. Instead, they use the 'this' value of the context they were created in
            - So if we changed the forEach loop to an arrow function, it would use its parent's 'this'
            - printPlacesLived: function() {
                  this.cities.forEach((city) => {
                      console.log(this.name + ' has lived in ' + city);
                  });
              } // This WORKS!
        - BUT!! Keep in mind that we DON'T always want this kind of functionality either!
            - Ex: On methods for instance - what if we made printPlacesLived an arrow function?
                - printPlacesLived: () => {
                      this.cities.forEach((city) => { // "Uncaught TypeError: Cannot read property 'cities' of undefined"
                          console.log(this.name + ' has lived in ' + city);
                      });
                  }
                
                    - We're getting undefined because remember-this arrow function doesn't bind its own 'this' value, so it's no longer equal to the object it's in;
                      It takes the 'this' from it's parent. Since the parent's scope is the global scope, 'this.cities' is undefined

                    - If you want to use the 'this', you HAVE to use an ES5 function -> printPlacesLived: function() {...}

        - printPlacesLived() {...}
            - ES6 shorthand for an ES5 syntax (printPlacesLived: function(){...})
            - Still let's us access 'arguments'
            - Still let's us have our 'this' binding

Events and Attributes
    - Some attributes work the same like they do in HTML, but there are some that have been renamed
        - Ex: const templateTwo = (
                  <div> 
                      <h1>Count: {count}</h1>
                      <button id="my-id" class="button">+1</button> // id = OK, class = ERROR!
                  </div>
              );

        - Some that are okay
            - id
        - Some that are NOT okay (or have been renamed)
            - 'class' 
                - now 'className', BUT if you inspect an element in HTML, it still shows as 'class' (get used to it kid...)
                    - This is because 'class' is a reserved word (for making classes..doy), remember you're making templates in a JSX file, not an HTML one!
        - You can see a full list of supported/changed attributes at https://reactjs.org/docs/dom-elements.html
            - Supported HTML attributes are now camelCase when using them!
    - You can also use a Javascript expression to set an attribute property, like 'id'

        - Ex:  const someId = 'myIdHere';
               <button id={someId} className="button">+1</button>

            - Just like Vue

    - Events
        - Similar to Vue
        - We're adding a custom event attribute to an element (onClick, etc)
        - See Example 1
            - If we wanted to, remember that just like referencing a variable (like {count}), we could put the arrow function in directly
                - Ex: <button onClick={() => {
                          console.log('some value here');
                      }}>+1</button>

Manual Data Binding
    - let count = 0;
      const addOne = () => {
          count++;
          console.log('addOne', count);
      };
      const templateTwo = (
          <div>
              <h1>Count: {count}</h1>
              <button onClick={addOne}>+1</button>
          </div>
      );
    
        - If you look at the console log, count is incrementing like it should be, but the html isn't changing! Why?
        - JSX does NOT have native data binding!!
            - Our template variable is rendered before anything is made. addOne is a static function, and on creation, count is set to 0
        - We need to run our code in templateTwo, and the ReactDOM.render(templateTwo, appRoot) line again to see the data change
            - Normally, we'd use React components to do this..but for now:
                - See Example 2
                    - This is basically an idea of how React does this behind the scenes
                    - Keep in mind that this is a horribly inefficient way to re-render on the screen-React is way more efficient in doing this
                        - It has a virtual DOM algorithms in place to determine the least amount of changes made in order to render/re-render new stuff in our application

Forms and Inputs
    - Say we have the following:
    
        -  <form>
                <input type="text" name="option"/>
                <button>Add Option</button>
           </form>

    - If you type something into the textbox and hit Enter (or the add option button), what happens?
        - The whole page reloads, and the text we put in the textbox gets added to the url! (http://127.0.0.1:8080/?option=test)
        - We don't want that to happen; In the past, that was a thing to help with server stuff, but no more (it's 2020 y'all...)
    - Let's use Events!
        - Putting an event on a <form> tag (onClick, etc.)
            - We'll use 'onSubmit' to handle when you submit something within the form
            - Events in React can also be known as 'Synthetic Events'
        - See Example 3
            - e.preventDefault();
            - preventDefault() is the method that stops the page from reloading/adding it's submission text into the URL - I get it now!
            - <form onSubmit={onFormSubmit}>
                - We don't call onFormSubmit(), with the parentheses, because that means we would get the return value of the method, and right now, it would return undefined
                    - It's the equivalent of writing <form onSubmit={undefined}>
                    - that's why we call it like it is-we just want to call a REFERENCE to the function

Arrays in JSX
    - Works out of the box
    - You can render numbers, strings, booleans, null, and undefined in Arrays
        - You CANNOT do objects! - remember...Objects are NOT supported out of the box in JSX!
    - <div>
        {
            [99, 98, 97]
        }
      </div>
    
        - When you render this to the screen, you get 999897
            - JSX renders array values side-by-side
            - This is the equivalent of writing {99}{98}{97}
                - This is actually what's happening behind the scenes when JSX is rendering your array
    - Normally, we can render JSX in JSX
        - Ex: {<p>1</p>} // Would render '1' to the screen
    - But, can you render an array of JSX in JSX?....YES!
        - Ex: {
                [<p>A</p>, <p>B</p>, <p>C</p>] // Renders A, B, and C in different lines, as <p> tags
              }

            - Hold on now! You'll notice we get an error in the console - "Warning: Each child in an array or iterator should have a unique "key" prop"
                - Arrays in JSX don't know how to re-render themselves
                    - Adding a key helps JSX optimize the rendering process, to figure out what small parts are needed/not needed for re-rendering
                    - Ex: { [<p key="1">A</p>, <p key="2">B</p>, <p key="3">C</p>] }
    - Converting our ordered list to be dynamic
        - <ol>
              {app.options.map((item) => <li key={item}>{item}</li>)}
          </ol> 

Picking an Option
    - <button disabled={app.options.length === 0} onClick={onMakeDecision}>What should I do?</button>
    - const onMakeDecision = () => {
          const randomNum = Math.floor(Math.random() * app.options.length);
          const option = app.options[randomNum];
          alert(option);
      };  







                                            EXAMPLES
                                            --------

Example 1 - Adding an Event
---------
const addOne = () => {
    console.log('addOne');
};
const templateTwo = (
    <div>
        <h1>Count: {count}</h1>
        <button onClick={addOne}>+1</button>
    </div>
);


Example 2 - Re-rendering our count w/ a function
---------
let count = 0;
const addOne = () => {
    count++;
    renderCounterApp(); // constant re-render
};

const appRoot = document.getElementById('app');

const renderCounterApp = () => {
    const templateTwo = (
        <div>
            <h1>Count: {count}</h1>
            <button onClick={addOne}>+1</button>
            <button onClick={minusOne}>-1</button>
            <button onClick={reset}>Reset</button>
        </div>
    );

    ReactDOM.render(templateTwo, appRoot);
};

renderCounterApp(); // Initial render


Example 3 - Event Handling in a Form
---------
const template = (
    <div>
        <form onSubmit={onFormSubmit}>
            <input type="text" name="option"/>
            <button>Add Option</button>
        </form>
    </div>
);

const onFormSubmit = (e) => {
    e.preventDefault();

    console.log('form submitted!');
};