                                                        NOTES
                                                        -----
Indecision App
--------------

Setting up a Web Server
    - live-server with npm

Hello React
    - Going to define a template, and then render it in the <body> of our index.html page
    - For now, use React by the CDN (<script>)
    - React can be used in many different contexts, such as react-vr for VR development, react-native, etc.
        - Each package gets installed separately
        - We're using react-dom -> Let's us render our React template to the browser
    - If you run live-server and check DevTools console, we now have access to the React and ReactDOM objects
    - JSX = Javascript XML
        - Javascript syntax extension - not part of the core language. It is provided by React
            - Other example of extending languages you might be familiar with -> CSS (SCSS, LESS)
        - In app.js -> var template = <p>This is JSX from app.js!</p>
            - Looks weird, but this is your first JSX static template, congrats!

        - var appRoot = document.getElementById('app');
          ReactDOM.render(template, appRoot);

            - ReactDOM.render(<template you want to render>, <element you want to render the template on>)
                - Used to render our template, as you can see
        - If you try to now run index.html in the browser, you get an "Unexpected token <" error - what gives??
            - Remember, JSX is NOT part of Javascript's core; It is an extension. That means that the browser doesn't understand html tags in your *js file!
        - To solve this, we need to convert our JSX code to JS code. We do this with Babel
            - We'll compile our JSX to JS, as well as compile it to ES5 code. We'll still be able to code in JSX, and let Babel do the work
            - So -> var template = <p>This is JSX from app.js!</p> now translates to -> var template = React.createElement("p", null, "This is JSX from app.js!");
                - React.createElement(<tag>, <attributes (object form)>, <content in tag>);
                    - Ex: React.createElement("h1", { id: "someId" }, "Something new"); -> <h1 id="someId">Something new</h1>
                - This is something the browser understands

Setting Up Babel
    - babel-cli@6.24.1
    - yarn init -> exactly like npm init
    - yarn.lock -> exactly like package-lock
    - Made a src/app.js file
        - This is where we will write our JSX code
        - Then, the babel compiled code will go into scripts/app.js, which index.html will look at in order to render everything on the page
    - babel src/app.js --out-file=public/scripts/app.js --presets=env,react
        - babel <file we want to compile> <file we want to dump our compiled code to> <any presets we want to use for the compilation process>
        - Calling the command changed the code in scripts/app.js!
        - You can add --watch to the previous command to automatically have changed compiled into scripts/app.js

Exploring JSX
    - Let's add more info besides our <h1> tag -> var template = <h1>Indecision App</h1><p>This is some info</p>;
    - If we try to compile the code we now get an error -> "JSX expressions must have one parent element"
        - Just like Vue with templates, with JSX, you can only have ONE root element, not two!
        - Solution: Surround everything in a <div> -> var template = <div><h1>Indecision App</h1><p>This is some info</p></div>;
            - You can put the code on new lines, save the file, and see that nothing changes in the browser. Babel understands that formatting:
                - var template =
                    <div>
                        <h1>Indecision App</h1>
                        <p>This is some info</p>
                    </div>;
            - The formatting can look a little wonky though. Total preference, but you can add parentheses in the beginning and end if you want:
                - var template = (
                    <div>
                        <h1>Indecision App</h1>
                        <p>This is some info</p>
                    </div>
                  )

JSX Expressions
    - <h1>Michael Ababio</h1>
        - Right now, this is statically defined. The only way to change this name is to go in the JSX file and manually change it
        - We want to replace it with a variable, so we can dynamically change the name
            - Just like Vue, etc.

    - var userName = 'Andrew';
      <h1>{userName}</h1>

        - Notice how we only use ONE set of curly braces
        - You can put any Javascript expression in there (again, like Vue, etc.)
        - Ex: var userName = 'Michael';
              var userAge = 26;
              var userLocation = 'Madison';
              var templateTwo = (
                  <div>
                      <h1>{userName}</h1>
                      <p>Age: {userAge}</p>
                      <p>Location: {userLocation}</p>
                  </div>
              ); 

        - What about objects??
            - var user = {
                name: 'Michael',
                age: 26,
                location: 'Madison'
              }
              <h1>{user}</h1> // Throws an error!

            - We get an error in the console that 'Objects are not valid as a React child'
            - Basically, React doesn't know how you want to render an object itself
                - You can still use an object's keys though -> <h1>{user.name}</h1> // This works!

Conditional Rendering in JSX
    - If statements, ternary, logical AND, OR, etc. are still the same
    - One neat thing to note: Remember that you use one set of curly braces to do a Javascript expression? You can also include tags in them!
        - Ex: {<h3>My h3</h3>}
            - This is helpful because you can create a function that could return the whole template tag in it if you wanted to
        - Note: If a Javascript expression returns undefined, the JSX does NOT return/show anything at all
            - It's as if you called 'display: none' on an element-it's just gone, and not on the DOM
            - undefined, null, and boolean values are IGNORED in JSX {true/false}, {null}, {undefined} // All of these will render nothing on the screen
    - Logical AND
        - Remember it's different in Javascript!

            - Ex: true && 'Some age' -> Returns 'Some Age'
                  false && 'Some age -> returns false

                - And since JSX doesn't render false values, if it's false it wont render anything

ES6 Aside: const and let
    - As expected, block level scoping; Try to avoid var

ES6 Aside: Arrow Functions (Parts I and II)
    - All arrow functions are anonymous; You can't 'name' an arrow function. The only way to reference it is to store it in a variable
        - Ex: const square = (x) => { return x * x; };
    - Arguments object is longer bound with arrow functions
        - // ES5
          const add = function(a, b) {
              console.log(arguments);
              return a + b;
          };
          console.log(add(55, 1));

          - With ES5, you could explicitly state your parameters like normal and be fine, but you also have access to the special 'arguments' object
          - I could change console.log to be -> console.log(add(55, 1, 1001));, and if i inspected the arguments object, it would have [55, 1, 1001, callee: {...}, etc.]
            - So basically it will show even anonymous amount of arguments
        - We no longer get access to this object with arrow functions
            - const add = (a, b) => {
                console.log(arguments);     // Error! 'arguments' is not defined!
                return a + b;
            };
            console.log(add(55, 1, 1001));

    - The 'this' keyword is no longer bound to arrow functions either!
        - // ES5
          const user = {
              name: 'Michael',
              cities: ['Madison', 'Platteville', 'Rothbury'],
              printPlacesLived: function() {
                  console.log(this.name);
                  console.log(this.cities);
              }
          };

          user.printPlacesLived();

            - If you look at the console, you'll notice that this.name and this.cities both prints out the correct values
            - That means that within the object, if this is in a value of a property, or a function value of a property, this can still access all of the object's values

            - What happens if we change it to this??
                - printPlacesLived: function() {
                  console.log(this.name);
                  console.log(this.cities);
  
                  this.cities.forEach(function(city) {
                      console.log(this.name + ' has lived in ' + city); // Ruh Roh!
                  });
                  ...
                  user.printPlacesLived();
              }

                - We get an ERROR! - It says this.name is not defined in our forEach loop!
                - 'this' is not bound to anything in our anonymous function, so it is set to undefined

            - Now, there have been workarounds for this already used in the past, such as
                - creating a 'that' variable
                    - printPlacesLived: function() {
                      const that = this;
                      this.cities.forEach(function(city) {
                          console.log(that.name + ' has lived in ' + city);
                      });
                  }
                  ...
                  user.printPlacesLived();

                    - Using 'that' allows you to have access to your object properties, even in nested functions

        - With ES6, arrow functions no longer bind their own 'this' value. Instead, they use the 'this' value of the context they were created in
            - So if we changed the forEach loop to an arrow function, it would use its parent's 'this'
            - printPlacesLived: function() {
                  this.cities.forEach((city) => {
                      console.log(this.name + ' has lived in ' + city);
                  });
              } // This WORKS!
        - BUT!! Keep in mind that we DON'T always want this kind of functionality either!
            - Ex: On methods for instance - what if we made printPlacesLived an arrow function?
                - printPlacesLived: () => {
                      this.cities.forEach((city) => { // "Uncaught TypeError: Cannot read property 'cities' of undefined"
                          console.log(this.name + ' has lived in ' + city);
                      });
                  }
                
                    - We're getting undefined because remember-this arrow function doesn't bind its own 'this' value, so it's no longer equal to the object it's in;
                      It takes the 'this' from it's parent. Since the parent's scope is the global scope, 'this.cities' is undefined

                    - If you want to use the 'this', you HAVE to use an ES5 function -> printPlacesLived: function() {...}

        - printPlacesLived() {...}
            - ES6 shorthand for an ES5 syntax (printPlacesLived: function(){...})
            - Still let's us access 'arguments'
            - Still let's us have our 'this' binding

Events and Attributes
    - Some attributes work the same like they do in HTML, but there are some that have been renamed
        - Ex: const templateTwo = (
                  <div> 
                      <h1>Count: {count}</h1>
                      <button id="my-id" class="button">+1</button> // id = OK, class = ERROR!
                  </div>
              );

        - Some that are okay
            - id
        - Some that are NOT okay (or have been renamed)
            - 'class' 
                - now 'className', BUT if you inspect an element in HTML, it still shows as 'class' (get used to it kid...)
                    - This is because 'class' is a reserved word (for making classes..doy), remember you're making templates in a JSX file, not an HTML one!
        - You can see a full list of supported/changed attributes at https://reactjs.org/docs/dom-elements.html
            - Supported HTML attributes are now camelCase when using them!
    - You can also use a Javascript expression to set an attribute property, like 'id'

        - Ex:  const someId = 'myIdHere';
               <button id={someId} className="button">+1</button>

            - Just like Vue

    - Events
        - Similar to Vue
        - We're adding a custom event attribute to an element (onClick, etc)
        - See Example 1
            - If we wanted to, remember that just like referencing a variable (like {count}), we could put the arrow function in directly
                - Ex: <button onClick={() => {
                          console.log('some value here');
                      }}>+1</button>

- Manual Data binding
    - 







                                            EXAMPLES
                                            --------

Example 1 - Adding an Event
---------
const addOne = () => {
    console.log('addOne');
};
const templateTwo = (
    <div>
        <h1>Count: {count}</h1>
        <button onClick={addOne}>+1</button>
    </div>
);


Example 2 -
---------
